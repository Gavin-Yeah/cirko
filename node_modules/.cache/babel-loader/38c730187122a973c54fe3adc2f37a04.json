{"ast":null,"code":"const get_location = callback => {\n  if (navigator.geolocation) {\n    navigator.geolocation.getCurrentPosition(function (position) {\n      var pos = {\n        lat: position.coords.latitude,\n        lng: position.coords.longitude\n      };\n      callback(pos);\n      return pos;\n    });\n  } else {\n    // Browser doesn't support Geolocation\n    console.log(\"error: Browser doesn't support Geolocation\");\n  }\n};\n/* pass the location and the result is the formatted address */\n\n\nconst geocodeLatLng = (location, callback) => {\n  var geocoder = new google.maps.Geocoder();\n  var latlng = {\n    lat: location.lat,\n    lng: location.lng\n  };\n  geocoder.geocode({\n    'location': latlng\n  }, function (results, status) {\n    if (status === 'OK') {\n      if (results[0]) {\n        callback(results[0].formatted_address);\n      } else {\n        window.alert('No results found');\n      }\n    } else {\n      window.alert('Geocoder failed due to: ' + status);\n    }\n  });\n};\n/* the result will be the list of posts which meet the requirement */\n\n\nconst fliter = (list_posts, distance, user_location, callback) => {\n  let mydestinations = [];\n  console.log(list_posts);\n\n  for (let i = 0; i < list_posts.length; i++) {\n    mydestinations.push(new google.maps.LatLng(list_posts[i].location.lat, list_posts[i].location.lng));\n  }\n\n  let ori = new google.maps.LatLng(user_location.lat, user_location.lng);\n  var service = new google.maps.DistanceMatrixService();\n  let return_list = [];\n  service.getDistanceMatrix({\n    origins: [ori],\n    destinations: mydestinations,\n    travelMode: 'WALKING'\n  }, (response, status) => {\n    return_list = fliter_help(response, status, distance, list_posts);\n    callback(return_list);\n  });\n};\n\nconst fliter_help = (response, status, dis, list_posts) => {\n  let distances = [];\n  let return_list = [];\n\n  if (status == 'OK') {\n    var origins = response.originAddresses;\n\n    for (var i = 0; i < origins.length; i++) {\n      var results = response.rows[i].elements;\n\n      for (var j = 0; j < results.length; j++) {\n        var element = results[j];\n        var distance = element.distance.value;\n        distances.push(distance);\n      }\n    }\n\n    for (let i = 0; i < distances.length; i++) {\n      if (distances[i] < dis) {\n        return_list.push(list_posts[i]);\n      }\n    }\n\n    return return_list;\n  }\n\n  return return_list;\n};\n\nexport { get_location, geocodeLatLng, fliter };","map":{"version":3,"sources":["/Users/jiadaye/workspace/cirko/src/components/utils/getLocation.js"],"names":["get_location","callback","navigator","geolocation","getCurrentPosition","position","pos","lat","coords","latitude","lng","longitude","console","log","geocodeLatLng","location","geocoder","google","maps","Geocoder","latlng","geocode","results","status","formatted_address","window","alert","fliter","list_posts","distance","user_location","mydestinations","i","length","push","LatLng","ori","service","DistanceMatrixService","return_list","getDistanceMatrix","origins","destinations","travelMode","response","fliter_help","dis","distances","originAddresses","rows","elements","j","element","value"],"mappings":"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","sourcesContent":["const get_location =(callback)=> {\n     if (navigator.geolocation) {\n         navigator.geolocation.getCurrentPosition(function (position) {\n             var pos = {\n                 lat: position.coords.latitude,\n                 lng: position.coords.longitude\n             };\n\n             callback(pos);\n             return pos;\n         });\n     } else {\n         // Browser doesn't support Geolocation\n         console.log(\"error: Browser doesn't support Geolocation\");\n\n     }\n }\n\n /* pass the location and the result is the formatted address */\nconst geocodeLatLng =(location, callback) =>{\n     var geocoder = new google.maps.Geocoder;\n     var latlng = {lat: location.lat, lng: location.lng};\n     geocoder.geocode({'location': latlng}, function(results, status) {\n         if (status === 'OK') {\n             if (results[0]) {\n                 callback(results[0].formatted_address);\n             } else {\n                 window.alert('No results found');\n             }\n         } else {\n             window.alert('Geocoder failed due to: ' + status);\n         }\n     });\n }\n\n /* the result will be the list of posts which meet the requirement */\nconst fliter =(list_posts, distance, user_location, callback)=>{\n     let mydestinations = [];\n     console.log(list_posts);\n     for(let i = 0; i<list_posts.length; i++) {\n         mydestinations.push(new google.maps.LatLng(list_posts[i].location.lat, list_posts[i].location.lng));\n     }\n     let ori = new google.maps.LatLng(user_location.lat, user_location.lng);\n     var service = new google.maps.DistanceMatrixService();\n     let return_list = [];\n     service.getDistanceMatrix(\n         {\n             origins: [ori],\n             destinations: mydestinations,\n             travelMode: 'WALKING'\n         }, (response, status)=>{return_list = fliter_help(response, status, distance, list_posts)\n             callback(return_list);\n         });\n }\n\nconst fliter_help =(response, status, dis, list_posts) =>{\n     let distances = [];\n     let return_list = [];\n     if (status == 'OK') {\n         var origins = response.originAddresses;\n\n         for (var i = 0; i < origins.length; i++) {\n             var results = response.rows[i].elements;\n             for (var j = 0; j < results.length; j++) {\n                 var element = results[j];\n                 var distance = element.distance.value;\n                 distances.push(distance);\n             }\n         }\n         for(let i = 0; i < distances.length; i++) {\n             if(distances[i] < dis) {\n                 return_list.push(list_posts[i]);\n             }\n         }\n         return return_list;\n     }\n     return return_list;\n }\nexport {get_location, geocodeLatLng, fliter}"]},"metadata":{},"sourceType":"module"}