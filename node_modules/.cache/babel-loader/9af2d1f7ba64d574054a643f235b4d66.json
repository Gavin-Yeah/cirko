{"ast":null,"code":"const get_location = callback => {\n  if (navigator.geolocation) {\n    navigator.geolocation.getCurrentPosition(function (position) {\n      var pos = {\n        lat: position.coords.latitude,\n        lng: position.coords.longitude\n      };\n      callback(pos);\n      return pos;\n    });\n  } else {\n    // Browser doesn't support Geolocation\n    console.log(\"error: Browser doesn't support Geolocation\");\n  }\n};\n/* pass the location and the result is the formatted address */\n// const geocodeLatLng =(location, callback) =>{\n//      var geocoder = new google.maps.Geocoder;\n//      var latlng = {lat: location.lat, lng: location.lng};\n//      geocoder.geocode({'location': latlng}, function(results, status) {\n//          if (status === 'OK') {\n//              if (results[0]) {\n//                  callback(results[0].formatted_address);\n//              } else {\n//                  window.alert('No results found');\n//              }\n//          } else {\n//              window.alert('Geocoder failed due to: ' + status);\n//          }\n//      });\n//  }\n\n/* the result will be the list of posts which meet the requirement */\n\n\nconst fliter = (list_posts, distance, user_location, callback) => {\n  let mydestinations = [];\n  console.log(list_posts);\n\n  for (let i = 0; i < list_posts.length; i++) {\n    mydestinations.push(new google.maps.LatLng(list_posts[i].location.lat, list_posts[i].location.lng));\n  }\n\n  let ori = new google.maps.LatLng(user_location.lat, user_location.lng);\n  var service = new google.maps.DistanceMatrixService();\n  let return_list = [];\n  service.getDistanceMatrix({\n    origins: [ori],\n    destinations: mydestinations,\n    travelMode: 'WALKING'\n  }, (response, status) => {\n    return_list = fliter_help(response, status, distance, list_posts);\n    callback(return_list);\n  });\n};\n\nconst fliter_help = (response, status, dis, list_posts) => {\n  let distances = [];\n  let return_list = [];\n\n  if (status == 'OK') {\n    var origins = response.originAddresses;\n\n    for (var i = 0; i < origins.length; i++) {\n      var results = response.rows[i].elements;\n\n      for (var j = 0; j < results.length; j++) {\n        var element = results[j];\n        var distance = element.distance.value;\n        distances.push(distance);\n      }\n    }\n\n    for (let i = 0; i < distances.length; i++) {\n      if (distances[i] < dis) {\n        return_list.push(list_posts[i]);\n      }\n    }\n\n    return return_list;\n  }\n\n  return return_list;\n};\n\nexport { get_location, fliter };","map":{"version":3,"sources":["/Users/jiadaye/workspace/cirko/src/components/utils/getLocation.js"],"names":["get_location","callback","navigator","geolocation","getCurrentPosition","position","pos","lat","coords","latitude","lng","longitude","console","log","fliter","list_posts","distance","user_location","mydestinations","i","length","push","google","maps","LatLng","location","ori","service","DistanceMatrixService","return_list","getDistanceMatrix","origins","destinations","travelMode","response","status","fliter_help","dis","distances","originAddresses","results","rows","elements","j","element","value"],"mappings":"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","sourcesContent":["const get_location =(callback)=> {\n     if (navigator.geolocation) {\n         navigator.geolocation.getCurrentPosition(function (position) {\n             var pos = {\n                 lat: position.coords.latitude,\n                 lng: position.coords.longitude\n             };\n\n             callback(pos);\n             return pos;\n         });\n     } else {\n         // Browser doesn't support Geolocation\n         console.log(\"error: Browser doesn't support Geolocation\");\n\n     }\n }\n\n /* pass the location and the result is the formatted address */\n// const geocodeLatLng =(location, callback) =>{\n//      var geocoder = new google.maps.Geocoder;\n//      var latlng = {lat: location.lat, lng: location.lng};\n//      geocoder.geocode({'location': latlng}, function(results, status) {\n//          if (status === 'OK') {\n//              if (results[0]) {\n//                  callback(results[0].formatted_address);\n//              } else {\n//                  window.alert('No results found');\n//              }\n//          } else {\n//              window.alert('Geocoder failed due to: ' + status);\n//          }\n//      });\n//  }\n\n /* the result will be the list of posts which meet the requirement */\nconst fliter =(list_posts, distance, user_location, callback)=>{\n     let mydestinations = [];\n     console.log(list_posts);\n     for(let i = 0; i<list_posts.length; i++) {\n         mydestinations.push(new google.maps.LatLng(list_posts[i].location.lat, list_posts[i].location.lng));\n     }\n     let ori = new google.maps.LatLng(user_location.lat, user_location.lng);\n     var service = new google.maps.DistanceMatrixService();\n     let return_list = [];\n     service.getDistanceMatrix(\n         {\n             origins: [ori],\n             destinations: mydestinations,\n             travelMode: 'WALKING'\n         }, (response, status)=>{return_list = fliter_help(response, status, distance, list_posts)\n             callback(return_list);\n         });\n }\n\nconst fliter_help =(response, status, dis, list_posts) =>{\n     let distances = [];\n     let return_list = [];\n     if (status == 'OK') {\n         var origins = response.originAddresses;\n\n         for (var i = 0; i < origins.length; i++) {\n             var results = response.rows[i].elements;\n             for (var j = 0; j < results.length; j++) {\n                 var element = results[j];\n                 var distance = element.distance.value;\n                 distances.push(distance);\n             }\n         }\n         for(let i = 0; i < distances.length; i++) {\n             if(distances[i] < dis) {\n                 return_list.push(list_posts[i]);\n             }\n         }\n         return return_list;\n     }\n     return return_list;\n }\nexport {get_location, fliter}"]},"metadata":{},"sourceType":"module"}